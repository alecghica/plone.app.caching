Plone caching to-do
===================

plone.caching
-------------

 [ ] Stop control flow exception from being logged in error_log
        - plone.app.caching may add this to the list of ignored exceptions on
          install

 [ ] Determine if we need a way to split the rule set/operation mapping
     according to arbitrary predicates, e.g. between anonymous and authenticated.
        - determine if we really need this first
        - can be solved in the same way as the chain operation, with a custom
            intermediary operation
        - possible predicates:
            - anonymous vs. authenticated
            - is item viewable by anonymous?
            - is debug mode enabled?
            - request values (e.g. status message, SearchableText)

plone.app.caching
-----------------
 
 [ ] Write IOperationLookup adapter for skin layer resources
        - look up by resource name and/or portal_type of parent
        - use custom mapping in plone.registry
 
 [ ] Build control panel
        - enable/disable caching
        - apply profile (search profiles for ICacheProfiles)
        - modify mappings
        - modify operation settings (global and per-ruleset)
 
 [ ] Build default operations and rules

 [ ] Implement ILastModified for Plone content

plone.app.cachepurging
----------------------

 [ ] Investigate purging strategies

Cache lookup investigations
===========================

The following things have been spotted as published objects, which we may want
to cache:

Page templates
--------------

**Types:**

* ``Products.CMFCore.FSPageTemplate.FSPageTemplate``
    => inherits: ``Products.PageTemplates.PageTemplate.PageTemplate``
* ``Products.PageTemplates.ZopePageTemplate.ZopePageTemplate``
    => inherits: ``Products.PageTemplates.PageTemplate.PageTemplate``

* ``Products.CMFFormController.FSControllerPageTemplate.FSControllerPageTemplate``
    => inherits: ``Products.CMFCore.FSPageTemplate.FSPageTemplate``
* ``Products.CMFFormController.ControllerPageTemplate.ControllerPageTemplate``
    => inherits: ``Products.PageTemplates.ZopePageTemplate.ZopePageTemplate``

**Strategy:**
    
* Register lookup for ``Products.PageTemplates.PageTemplate.PageTemplate``
* Lookup rule by name (``__name__``)
* Fall back to lookup rule by context type (``__parent__``)
* Maybe allow cache rules registered for content types instead of mapping?

Zope 2 style resources
----------------------

**Types:**

* ``Products.CMFCore.FSFile.FSFile`` (via ``index_html``)
    => through skin layer
* ``Products.CMFCore.FSImage.FSImage`` (via ``index_html``)
    => through skin layer
* ``OFS.Image.File`` (via ``index_html``)
    => can be customised resource
    => or ResourceRegistries wrapper

* ``OFS.Image.Image`` (via ``index_html``)
    => inherits: ``OFS.Image.File``
    => can be customised resource

**Strategy:**

* Register cache rule for 
    => ``Products.CMFCore.FSFile.FSFile``,
    => ``Products.CMFCore.FSImage.FSImage``
    => ``OFS.Image.File``
    => name: ``zope-resource``

Zope 3 style resources
----------------------

**Types:**

* ``Products.Five.metaclass.ConcatResourceN``
* ``Products.Five.metaclass.DirContainedFileResourceN``
* ``Products.Five.metaclass.FileResourceN``
    => all generated

**Real classes:**

* ``zope.app.publisher.browser.fileresource.FileResource``
    => sets own cache headers
* ``zope.app.publisher.browser.resource.Resource``
    => base class for standard Zope resources, but not KSS concat resources
* ``Products.Five.browser.resource.Resource``
    => base class for resources generated by Five

**Strategy:**

* Register cache rule for ``Products.Five.browser.resource.Resource``
    => name: ``filesystem-resource``

Other
-----

For now, we will ignore these:

* DTML methods (skin layers and TTW)
* ``App.ImageFile.ImageFile`` (used in the ZMI)
* STX and reST files (from CMF)
* Python scripts (skin layers and TTW)
* Form controller scripts and validators (skin layers and TTW)
